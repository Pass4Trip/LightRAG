import os
import logging
import pika
import json
import httpx

# Configuration du logging
logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Param√®tres de connexion RabbitMQ depuis les variables d'environnement
RABBITMQ_HOST = os.getenv('RABBITMQ_HOST', '51.77.200.196')  # Utiliser le nom de service Kubernetes
RABBITMQ_PORT = int(os.getenv('RABBITMQ_PORT', '30645'))  # Port standard de RabbitMQ
RABBITMQ_USER = os.getenv('RABBITMQ_USER', 'rabbitmq')
RABBITMQ_PASSWORD = os.getenv('RABBITMQ_PASSWORD', 'mypassword')
RABBITMQ_QUEUE = os.getenv('RABBITMQ_QUEUE', 'queue_vinh_test')

# Configuration flexible de l'API d'insertion
API_LIGHTRAG_URL = 'http://51.77.200.196:30080/insert'

logger.debug(f"üåê URL d'insertion configur√©e : {API_LIGHTRAG_URL}")

def sync_send_to_insert_api(payload: dict):
    """
    Version synchrone de l'envoi √† l'API d'insertion de LightRAG avec gestion des redirections

    Args:
        payload (dict): Message √† ins√©rer
    """
    try:
        # Configuration du client avec gestion des redirections
        with httpx.Client(
            timeout=10.0, 
            follow_redirects=True,  # Activer le suivi des redirections
            max_redirects=3  # Limiter le nombre de redirections
        ) as client:
            # Ajout de logs d√©taill√©s pour le d√©bogage
            logger.info(f"üöÄ Tentative d'insertion du message vers {API_LIGHTRAG_URL}")
            
            response = client.post(API_LIGHTRAG_URL, json=payload)
            
            # Log de la requ√™te et de la r√©ponse
            logger.info(f"üì° Requ√™te HTTP: {response.request.method} {response.request.url}")
            logger.info(f"üì• R√©ponse HTTP: {response.status_code} {response.reason_phrase}")
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Message ins√©r√© avec succ√®s : {payload}")
                logger.debug(f"D√©tails de la r√©ponse : {response.text}")
            else:
                logger.error(f"‚ùå √âchec de l'insertion : {response.status_code} - {response.text}")
                logger.error(f"URL finale : {response.url}")
    
    except httpx.RequestError as e:
        logger.error(f"‚ùå Erreur de requ√™te r√©seau : {e}")
    except httpx.HTTPStatusError as e:
        logger.error(f"‚ùå Erreur HTTP : {e}")
    except Exception as e:
        logger.error(f"‚ùå Erreur inattendue lors de l'envoi √† l'API : {e}")

def callback(ch, method, properties, body):
    """
    Fonction de callback appel√©e √† la r√©ception de chaque message.
    Traite tous les messages RabbitMQ de mani√®re synchrone.
    
    Args:
        ch (pika.channel.Channel): Canal de communication RabbitMQ
        method (pika.spec.Basic.Deliver): M√©thode de livraison
        properties (pika.spec.BasicProperties): Propri√©t√©s du message
        body (bytes): Corps du message
    """
    try:
        # D√©coder le message
        message = body.decode('utf-8')
        
        # Tenter de parser comme JSON si possible
        try:
            parsed_message = json.loads(message)
            logger.debug(f"üì® Message re√ßu (JSON) : {parsed_message}")
            
            # Envoi synchrone √† l'API
            sync_send_to_insert_api(parsed_message)
        
        except json.JSONDecodeError:
            logger.error(f"üì® Message re√ßu (texte brut) : {message}")
        
        # Acquittement du message
        ch.basic_ack(delivery_tag=method.delivery_tag)
    
    except Exception as e:
        logger.error(f"‚ùå Erreur lors du traitement du message : {e}")
        # Rejeter le message en cas d'erreur
        ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)

def start_consuming():
    """
    D√©marrer la consommation de messages depuis la queue
    """
    try:
        # √âtablir la connexion
        credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASSWORD)
        parameters = pika.ConnectionParameters(
            host=RABBITMQ_HOST, 
            port=RABBITMQ_PORT,
            credentials=credentials
        )
        
        connection = pika.BlockingConnection(parameters)
        channel = connection.channel()
        
        # D√©clarer la queue
        channel.queue_declare(queue=RABBITMQ_QUEUE, durable=True)
        
        # Configuration du QoS
        channel.basic_qos(prefetch_count=1)
        
        # Commencer √† consommer
        logger.info(f"üöÄ D√©marrage de l'√©coute sur la queue {RABBITMQ_QUEUE}")
        channel.basic_consume(
            queue=RABBITMQ_QUEUE, 
            on_message_callback=callback
        )
        
        # D√©marrer la consommation
        channel.start_consuming()
    
    except Exception as e:
        logger.error(f"‚ùå Erreur de connexion ou de consommation : {e}")

def main():
    """
    Point d'entr√©e principal
    """
    try:
        logger.info("üîå Initialisation du listener RabbitMQ")
        start_consuming()
    except KeyboardInterrupt:
        logger.info("üõë Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"‚ùå Erreur critique : {e}")

if __name__ == "__main__":
    main()
